# 예상되는 문제점 및 개선 제안

이 문서는 프로젝트의 잠재적인 메모리 비효율성 및 성능 문제를 기록합니다.

---

## 파일: `template/views.py`

### 문제점 1: `ViewTemplateListView`의 페이지네이션(Pagination) 부재 (심각도: 높음)

- **위치**: `get` 메소드
- **코드**:
  ```python
  templates = Template.objects.filter(user=admin)
  serializer = ViewTemplateSerializer(templates, many=True)
  ```
- **설명**: 관리자가 생성한 모든 템플릿을 한 번에 데이터베이스에서 조회하여 메모리에 올립니다. 템플릿 개수가 많아지면 API 호출 시 서버 메모리가 급격히 소모될 수 있습니다.
- **수정 제안**: `APIView` 대신 `generics.ListAPIView`를 상속하여 페이지네이션 기능을 적용해야 합니다.
- **참고**: 이 수정은 API 응답 구조를 변경하므로 프론트엔드 코드의 수정이 필요합니다. (`[{}, {}]` -> `{"count": N, "results": [{}, {}]}`)

### 문제점 2: `MyTemplateListView`의 페이지네이션(Pagination) 부재 (심각도: 높음)

- **위치**: `get` 메소드
- **코드**:
  ```python
  templates = Template.objects.filter(user=user)
  serializer = MyTemplateSerializer(templates, many=True)
  ```
- **설명**: 특정 유저가 생성한 모든 '내 템플릿'을 한 번에 메모리로 불러옵니다. 유저가 템플릿을 많이 만들수록 메모리 문제가 발생할 확률이 높습니다.
- **수정 제안**: `generics.ListAPIView`를 상속하여 페이지네이션 기능을 적용해야 합니다.
- **참고**: 이 수정 역시 API 응답 구조를 변경하므로 프론트엔드 코드의 수정이 필요합니다.

---

## 파일: `user/views.py`

### 문제점: `SignOutView`의 동기적 외부 API 호출 (성능 병목 가능성)

- **위치**: `post` 메소드
- **코드**:
  ```python
  r = requests.post(
      f"{settings.CLERK_API_BASE}/sessions/{sid}/revoke",
      headers={"Authorization": f"Bearer {settings.CLERK_API_KEY}"},
      timeout=5,
  )
  ```
- **설명**: 외부 서비스(Clerk) API를 동기 방식으로 호출하고 있어, 외부 API의 응답이 지연될 경우 서버 워커 프로세스를 점유하게 됩니다. 이는 동시 사용자가 많을 때 서버 전체의 응답성을 저하시켜, 마치 서버가 멈추는 것과 같은 현상을 유발할 수 있는 잠재적인 성능 병목 지점입니다.
- **수정 제안**: 강제 로그아웃 기능의 사용 빈도가 매우 낮다면 현 상태를 유지해도 무방합니다. 하지만 안정성을 극대화하려면, 해당 API 호출을 Celery와 같은 비동기 태스크 큐로 이전하여 백그라운드에서 처리하는 것이 이상적입니다.

---

## 파일: `email_account/serializers.py`

### 문제점: `EmailAccountCreateSerializer`의 동기적 IMAP 검증 (성능 병목 가능성)

- **위치**: `validate` 메소드
- **코드**:
  ```python
  with imaplib.IMAP4_SSL(imap_host, imap_port) as imap:
      imap.login(address, password)
  ```
- **설명**: 새로운 이메일 계정을 등록할 때, 외부 IMAP 서버에 동기 방식으로 로그인을 시도하여 유효성을 검사합니다. 상대 IMAP 서버의 응답이 느릴 경우, 이 과정이 서버 프로세스를 대기 상태로 만들어 동시 요청 처리 성능을 저하시킬 수 있습니다.
- **수정 제안**: 이상적으로는 계정을 `is_valid=False` 상태로 먼저 생성하고, 비동기 작업(예: Celery)으로 IMAP 검증을 위임하는 것이 좋습니다. Celery를 사용하지 않는 현재 구조에서는 이 부분이 성능 병목 지점으로 남을 수 있음을 인지하고 있어야 합니다.

---

## 파일: `utils/summarizer.py`

### 문제점: 부정확한 시스템 프롬프트 (개선 제안)

- **위치**: `summarize_email_content` 함수 내 `system_instruction`
- **코드**:
  ```python
  if is_html:
      system_instruction += """
      ...
      If the HTML contains no discernible text and seems to be composed only of images or tracking pixels, analyze them and state proper summary.
      ...
      """
  ```
- **설명**: 현재 LLM은 텍스트 기반이므로 프롬프트에 포함된 "이미지를 분석하라"는 지시를 수행할 수 없습니다. 이로 인해 예측 불가능한 요약 결과가 나오거나, LLM의 작업 효율이 저하될 수 있습니다.
- **수정 제안**: 향후 이미지 분석이 가능한 멀티모달(multimodal) 모델로 업그레이드할 계획이 없다면, 이 지침을 "이미지로만 구성된 광고성 메일입니다" 와 같이 명확한 대체 텍스트를 반환하도록 수정하는 것이 좋습니다.
- **조치**: 사용자 요청에 따라, 향후 모델 업그레이드 가능성을 고려하여 현 상태를 유지하고 기록만 남깁니다.

---

## 파일: `template/models.py`

### 문제점: `__str__` 메소드의 관계 참조로 인한 N+1 쿼리 가능성 (심각도: 보통)

- **위치**: `Template` 모델의 `__str__` 메소드
- **코드**:
  ```python
  def __str__(self):
      return f"Template#{self.id} of {self.email_account.address}"
  ```
- **설명**: `__str__` 메소드가 관계 필드인 `self.email_account`에 접근합니다. 이로 인해 Django Admin 등에서 템플릿 목록을 조회할 때, 각 항목마다 `email_account` 정보를 가져오기 위한 추가 쿼리가 발생하여 N+1 문제가 생길 수 있습니다. 이는 Admin 페이지의 응답 속도를 저하시키는 원인이 됩니다.
- **수정 제안**: `template/admin.py`에서 `Template` 모델의 `ModelAdmin`에 `list_select_related = ('email_account',)` 옵션을 추가하여, 목록 조회 시 관련 객체를 한 번의 쿼리로 함께 가져오도록 최적화해야 합니다.
- **조치**: 사용자 요청에 따라, 현재는 API 성능에 직접적인 영향이 적으므로 기록만 남기고 넘어갑니다.

---

## 파일: `config/settings.py`

### 문제점: 운영 환경에 부적합한 설정 (심각도: 매우 높음)

- **항목 1: SQLite 데이터베이스 사용**
    - **설명**: `DATABASES` 설정이 `sqlite3`로 되어 있습니다. SQLite는 동시 쓰기 요청을 처리하지 못하고 데이터베이스를 잠그기 때문에, 사용자가 조금만 몰려도 서버 전체가 극심하게 느려지거나 멈추는 현상의 직접적인 원인이 됩니다.
    - **조치**: 운영 환경에서는 반드시 PostgreSQL, MySQL 등 독립된 데이터베이스 서버를 사용하도록 변경해야 합니다.

- **항목 2: 로컬 메모리 캐시 사용 (`LocMemCache`)**
    - **설명**: `CACHES` 설정이 `LocMemCache`로 되어 있습니다. 웹 서버가 여러 프로세스로 동작할 경우, 각 프로세스마다 별도의 캐시가 생성되어 메모리를 낭비하고 캐시 데이터의 불일치를 유발합니다.
    - **조치**: 운영 환경에서는 모든 프로세스가 공유하는 외부 캐시(예: Redis, Memcached)를 사용하도록 변경해야 합니다.

---

## 파일: `email_content/service/smtp.py`

### 문제점: 이메일 발송 시 동기적 SMTP 통신 (성능 병목 가능성)

- **위치**: `_connect` 함수
- **코드**:
  ```python
  server = smtplib.SMTP_SSL(...)
  server.login(...)
  ```
- **설명**: 외부 SMTP 서버에 연결하고 로그인하는 과정은 동기적 네트워크 통신입니다. 만약 메일을 보내는 SMTP 서버의 응답이 느릴 경우, API 요청을 처리하는 서버 프로세스가 응답을 기다리는 동안 멈춰있게 되어 서버 전체의 응답성을 저하시킬 수 있습니다.
- **조치**: 이 문제 역시 `예상되는문제점.md`에 기록하고, 추후 비동기 태스크 처리 도입 시 함께 개선하는 것을 권장합니다.